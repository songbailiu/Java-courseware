<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0050)http://www.itisedu.com/phrase/200604261004365.html -->
<HTML><HEAD><TITLE>Java虚拟机</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<META content="MSHTML 6.00.2900.3059" name=GENERATOR></HEAD>
<BODY>
<CENTER>
<H1>Java虚拟机</H1></CENTER>
<DIV>
<P align=right><FONT face=Verdana><FONT face=Verdana><FONT face=Verdana><FONT 
face=Verdana><FONT color=#f70938><FONT face=黑体><A 
href="http://www.itisedu.com/phrase/200604112229525.html" 
target=_new>中科永联</A>高级技术培训中心（</FONT><FONT face=黑体>www.itisedu.com</FONT><FONT 
face=黑体>）<IMG src="Java虚拟机.files/200642610045200.jpg" 
border=0></FONT></FONT></FONT></FONT></FONT></FONT></P>
<P><FONT face=Verdana>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A 
href="http://www.itisedu.com/phrase/200604261004365.html" 
target=_new>Java虚拟机</A>(<A 
href="http://www.itisedu.com/phrase/200604261007235.html" 
target=_new>JVM</A>)一种用于计算设备的规范，可用不同的方式（<A 
href="http://www.itisedu.com/phrase/200604232134205.html" 
target=_new>软件</A>或硬件）加以实现。编译虚拟机的指令集与编译微处理器的指令集非常<A 
href="http://www.itisedu.com/phrase/200603090857555.html" 
target=_new>类</A>似。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Java虚拟机(JVM)是可运行Java代码的假想<A 
href="http://www.itisedu.com/phrase/200603021438435.html" 
target=_new>计算机</A>。只要根据JVM规格描述将解释器移植到特定的计算机上，就能保证经过编译的任何Java代码能够在该系统上运行。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java虚拟机是一个想象中的机器,在实际的计算机上通过软件模拟来实现。Java虚拟机有自己想象中的硬件,如处理器、堆栈、寄存器等,还具有相应的指令系统。</P>
<P><STRONG>一、Java虚拟机(JVM)概述</STRONG></P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.为什么要使用Java虚拟机</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行,至少需要编译成不同的目标代码。而引入Java语言虚拟机后,Java语言在不同平台上运行时不需要重新编译。Java语言使用<A 
href="http://www.itisedu.com/phrase/200603061709535.html" 
target=_new>模式</A>Java虚拟机屏蔽了与具体平台相关的信息,使得Java语言编译<A 
href="http://www.itisedu.com/phrase/200604232224305.html" 
target=_new>程序</A>只需生成在Java虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时,把字节码解释成具体平台上的机器指令执行。</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.谁需要了解Java虚拟机</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java虚拟机是Java语言底层实现的基础,对Java语言感兴趣的人都应对Java虚拟机有个大概的了解。这有助于理解Java语言的一些性质,也有助于使用Java语言。对于要在特定平台上实现Java虚拟机的软件人员,Java语言的编译器作者以及要用硬件芯片实现Java虚拟机的人来说,则必须深刻理解Java虚拟机的规范。另外,如果你想扩展Java语言,或是把其它语言编译成Java语言的字节码,你也需要深入地了解Java虚拟机。</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.Java虚拟机支持的数据<A 
href="http://www.itisedu.com/phrase/200603051002565.html" target=_new>类型</A></P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Java虚拟机支持Java语言的基本数据类型如下:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte://1字节有符号整数的补码 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short://2字节有符号整数的补码 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int://4字节有符号整数的补码 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long://8字节有符号整数的补码 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float://4字节IEEE754单精度浮点数 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double://8字节IEEE754双精度浮点数 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char://2字节无符号Unicode字符</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 几乎所有的Java类型检查都是在编译时完成的。上面列出的<A 
href="http://www.itisedu.com/phrase/200604091753595.html" 
target=_new>原始数据</A>类型的数据在Java执行时不需要用硬件标记。操作这些原始数据类型数据的字节码(指令)本身就已经指出了操作数的数据类型,例如iadd、ladd、fadd和dadd指令都是把两个数相加,其操作数类型别是int、long、float和double。虚拟机没有给boolean(布尔)类型设置单独的指令。boolean型的数据是由integer指令,包括integer返回来处理的。boolean型的数组则是用byte数组来处理的。虚拟机使用IEEE754格式的浮点数。不支持IEEE格式的较旧的计算机,在运行Java数值计算程序时,可能会非常慢。</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虚拟机支持的其它数据类型包括: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A 
href="http://www.itisedu.com/phrase/200604231338435.html" 
target=_new>object</A>//对一个Javaobject(<A 
href="http://www.itisedu.com/phrase/200603090845215.html" 
target=_new>对象</A>)的4字节引用 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
returnAddress//4字节,用于jsr/ret/jsr-w/ret-w指令 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
注:Java数组被当作object处理。</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
虚拟机的规范对于object内部的结构没有任何特殊的要求。在Sun公司的实现中,对object的引用是一个句柄,其中包含一对指针:一个指针指向该object的方法表,另一个指向该object的数据。用Java虚拟机的字节码表示的程序应该遵守类型规定。Java虚拟机的实现应拒绝执行违反了类型规定的字节码程序。Java虚拟机由于字节码定义的限制似乎只能运行于32位地址空间的机器上。但是可以创建一个Java虚拟机,它自动地把字节码转换成64位的形式。从Java虚拟机支持的数据类型可以看出,Java对数据类型的内部格式进行了严格规定,这样使得各种Java虚拟机的实现对数据的解释是相同的,从而保证了Java的与平台无关性和可 
<BR>移植性。</P>
<P><BR><STRONG>二、Java虚拟机JVM规格描述</STRONG></P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
JVM的设计目标是提供一个基于抽象规格描述的计算机模型，为解释程序开发人员提很好的灵活性，同时也确保Java代码可在符合该规范的任何系统上运行。JVM对其实现的某些方面给出了具体的定义，特别是对Java可执行代码，即字节码(Bytecode)的格式给出了明确的规格。这一规格包括操作码和操作数的语法和数值、标识符的数值表示方式、以及Java类<A 
href="http://www.itisedu.com/phrase/200602282323195.html" 
target=_new>文件</A>中的Java对象、常量缓冲池在JVM的存储映象。这些定义为JVM解释器开发人员提供了所需的信息和开发环境。Java的设计者希望给开发人员以随心所欲使用Java的自由。 
　　　　JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是： 　　<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
*JVM指令系统 　　<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *JVM寄存器 
　　<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *JVM栈结构 
　　<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *JVM碎片回收堆 
　　<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *JVM存储区 </P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1JVM指令系统 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JVM指令系统同其他计算机的指令系统极其相似。Java指令也是由 
操作码和操作数两部分组成。操作码为8位二进制数，操作数进紧随在操作码的后面，其长度根据需要而不同。操作码用于指定一条指令操作的性质（在这里我们采用汇编符号的形式进行说明），如iload表示从存储器中装入一个整数，anewarray表示为一个新数组分配空间，iand表示两个整数的"与"，ret用于流程控制，表示从对某一方法的调用中返回。当长度大于8位时，操作数被分为两个以上字节存放。JVM采用了"big 
endian"的编码方式来处理这种情况，即高位bits存放在低字节中。这同 Motorola及其他的RISC 
CPU采用的编码方式是一致的，而与Intel采用的"little endian "的编码方式即低位bits存放在低位字节的方法不同。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java指令系统是以Java语言的实现为目的设计的，其中包含了用于调用方法和监视多先程系统的指令。Java的8位操作码的长度使得JVM最多有256种指令，目前已使用了160多种操作码。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2JVM指令系统 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
所有的CPU均包含用于保存系统状态和处理器所需信息的寄存器组。如果虚拟机定义较多的寄存器，便可以从中得到更多的信息而不必对栈或内存进行访问，这有利于提高运行速度。然而，如果虚拟机中的寄存器比实际CPU的寄存器多，在实现虚拟机时就会占用处理器大量的时间来用常规存储器模拟寄存器，这反而会降低虚拟机的效率。针对这种情况，JVM只设置了4个最为常用的寄存器。它们是： 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pc程序计数器 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
optop操作数栈顶指针 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame当前执行环境指针 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vars指向当前执行环境中第一个局部变量的指针 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
所有寄存器均为32位。pc用于记录程序的执行。optop,frame和vars用于记录指向Java栈区的指针。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.3JVM栈结构 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
作为基于栈结构的计算机，Java栈是JVM存储信息的主要方法。当JVM得到一个Java字节码应用程序后，便为该代码中一个类的每一个方法创建一个栈<A 
href="http://www.itisedu.com/phrase/200603061723295.html" 
target=_new>框架</A>，以保存该方法的状态信息。每个栈框架包括以下三类信息： <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
局部变量 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 执行环境 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
操作数栈</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
局部变量用于存储一个类的方法中所用到的局部变量。vars寄存器指向该变量表中的第一个局部变量。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
执行环境用于保存解释器对Java字节码进行解释过程中所需的信息。它们是：上次调用的方法、局部变量指针和操作数栈的栈顶和栈底指针。执行环境是一个执行一个方法的控制中心。例如：如果解释器要执行iadd(整数加法)，首先要从frame寄存器中找到当前执行环境，而后便从执行环境中找到操作数栈，从栈顶弹出两个整数进行加法运算，最后将结果压入栈顶。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 操作数栈用于存储运算所需操作数及运算的结果。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.4JVM碎片回收堆 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java类的实例所需的存储空间是在堆上分配的。解释器具体承担为类实例分配空间的工作。解释器在为一个实例分配完存储空间后，便开始记录对该实例所占用的内存区域的使用。一旦对象使用完毕，便将其回收到堆中。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
在Java语言中，除了new语句外没有其他方法为一对象申请和释放内存。对内存进行释放和回收的工作是由Java运行系统承担的。这允许Java运行系统的设计者自己决定碎片回收的方法。在SUN公司开发的Java解释器和Hot 
Java环境中，碎片回收用后台<A href="http://www.itisedu.com/phrase/200603091754305.html" 
target=_new>线程</A>的方式来执行。这不但为运行系统提供了良好的性能，而且使<A 
href="http://www.itisedu.com/phrase/200602281641255.html" 
target=_new>程序设计</A>人员摆脱了自己控制内存使用的风险。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.5JVM存储区 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
JVM有两类存储区：常量缓冲池和方法区。常量缓冲池用于存储类名称、方法和字段名称以及串常量。方法区则用于存储Java方法的字节码。对于这两种存储区域具体实现方式在JVM规格中没有明确规定。这使得Java应用程序的存储布局必须在运行过程中确定，依赖于具体平台的实现方式。<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
JVM是为Java字节码定义的一种独立于具体平台的规格描述，是Java平台独立性的基础。目前的JVM还存在一些限制和不足，有待于进一步的完善，但无论如何，JVM的思想是成功的。</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
对比分析：如果把Java原程序想象成我们的C++原程序，Java原程序编译后生成的字节码就相当于C++原程序编译后的80x86的机器码（二进制程序文件），JVM虚拟机相当于80x86计算机系统,Java解释器相当于80x86CPU。在80x86CPU上运行的是机器码，在Java解释器上运行的是Java字节码。</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java解释器相当于运行Java字节码的“CPU”,但该“CPU”不是通过硬件实现的，而是用软件实现的。Java解释器实际上就是特定的平台下的一个应用程序。只要实现了特定平台下的解释器程序，Java字节码就能通过解释器程序在该平台下运行，这是Java跨平台的根本。当前，并不是在所有的平台下都有相应Java解释器程序，这也是Java并不能在所有的平台下都能运行的原因，它只能在已实现了Java解释器程序的平台下运行。</P>
<P><BR><STRONG>三、Java虚拟机JVM的<A 
href="http://www.itisedu.com/phrase/200603122156385.html" 
target=_new>体系结构</A></STRONG> </P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
刚才已经提到，JVM可以由不同的厂商来实现。由于厂商的不同必然导致JVM在实现上的一些不同，然而JVM还是可以实现跨平台的特性，这就要归功于设计JVM时的体系结构了。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们知道，一个JVM实例的行为不光是它自己的事，还涉及到它的<A 
href="http://www.itisedu.com/phrase/200604161433025.html" 
target=_new>子系统</A>、存储区域、数据类型和指令这些部分，它们描述了JVM的一个抽象的内部体系结构，其目的不光规定实现JVM时它内部的体系结构，更重要的是提供了一种方式，用于严格定义实现时的外部行为。每个JVM都有两种机制，一个是装载具有合适名称的类(类或是接口)，叫做类装载子系统；另外的一个负责执行包含在已装载的类或接口中的指令，叫做运行引擎。每个JVM又包括方法区、堆、Java栈、程序计数器和本地方法栈这五个部分，这几个部分和类装载机制与运行引擎机制一起组成的体系结构图为： 
</P>
<P align=center><IMG src="Java虚拟机.files/200642610323548.jpg" 
border=0><BR>图3JVM的体系结构 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
JVM的每个实例都有一个它自己的方法域和一个堆，运行于JVM内的所有的线程都共享这些区域；当虚拟机装载类文件的时候，它解析其中的二进制数据所包含的类信息，并把它们放到方法域中；当程序运行的时候，JVM把程序初始化的所有对象置于堆上；而每个线程创建的时候，都会拥有自己的程序计数器和Java栈，其中程序计数器中的值指向下一条即将被执行的指令，线程的Java栈则存储为该线程调用Java方法的状态；本地方法调用的状态被存储在本地方法栈，该方法栈依赖于具体的实现。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面分别对这几个部分进行说明。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
执行引擎处于JVM的核心位置，在Java虚拟机规范中，它的行为是由指令集所决定的。尽管对于每条指令，规范很详细地说明了当JVM执行字节码遇到指令时，它的实现应该做什么，但对于怎么做却言之甚少。Java虚拟机支持大约248个字节码。每个字节码执行一种基本的CPU运算,例如,把一个整数加到寄存器,子程序转移等。Java指令集相当于Java程序的汇编语言。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java指令集中的指令包含一个单字节的操作符,用于指定要执行的操作,还有0个或多个操作数,提供操作所需的参数或数据。许多指令没有操作数,仅由一个单字节的操作符构成。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虚拟机的内层循环的执行过程如下: </P>
<P>&nbsp;</P>
<P>do{ </P>
<P>取一个操作符字节; </P>
<P>根据操作符的值执行一个动作; </P>
<P>}while(程序未结束) </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
由于指令系统的简单性,使得虚拟机执行的过程十分简单,从而有利于提高执行的效率。指令中操作数的数量和大小是由操作符决定的。如果操作数比一个字节大,那么它存储的顺序是高位字节优先。例如,一个16位的参数存放时占用两个字节,其值为: 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一个字节*256+第二个字节字节码。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
指令流一般只是字节对齐的。指令tableswitch和lookup是例外,在这两条指令内部要求强制的4字节边界对齐。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
对于本地方法接口，实现JVM并不要求一定要有它的支持，甚至可以完全没有。Sun公司实现Java本地接口(<A 
href="http://www.itisedu.com/phrase/200604261218435.html" 
target=_new>JNI</A>)是出于可移植性的考虑，当然我们也可以设计出其它的本地接口来代替Sun公司的JNI。但是这些设计与实现是比较复杂的事情，需要确保垃圾回收器不会将那些正在被本地方法调用的对象释放掉。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java的堆是一个运行时数据区,类的实例(对象)从中分配空间，它的管理是由垃圾回收来负责的:不给程序员显式释放对象的能力。Java不规定具体使用的垃圾回收算法,可以根据系统的<A 
href="http://www.itisedu.com/phrase/200603101518295.html" 
target=_new>需求</A>使用各种各样的算法。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java方法区与传统语言中的编译后代码或是Unix进程中的正文段类似。它保存方法代码(编译后的java代码)和符号表。在当前的Java实现中,方法代码不包括在垃圾回收堆中,但计划在将来的版本中实现。每个类文件包含了一个Java类或一个Java界面的编译后的代码。可以说类文件是Java语言的执行代码文件。为了保证类文件的平台无关性,Java虚拟机规范中对类文件的格式也作了详细的说明。其具体细节请参考Sun公司的Java虚拟机规范。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java虚拟机的寄存器用于保存机器的运行状态,与微处理器中的某些专用寄存器类似。Java虚拟机的寄存器有四种: </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pc: Java程序计数器； </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optop: 指向操作数栈顶端的指针； </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frame: 指向当前执行方法的执行环境的指针；。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vars: 指向当前执行方法的局部变量区第一个变量的指针。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
在上述体系结构图中，我们所说的是第一种，即程序计数器，每个线程一旦被创建就拥有了自己的程序计数器。当线程执行Java方法的时候，它包含该线程正在被执行的指令的地址。但是若线程执行的是一个本地的方法，那么程序计数器的值就不会被定义。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Java虚拟机的栈有三个区域:局部变量区、运行环境区、操作数区。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 局部变量区 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
每个Java方法使用一个固定大小的局部变量集。它们按照与vars寄存器的字偏移量来寻址。局部变量都是32位的。长整数和双精度浮点数占据了两个局部变量的空间,却按照第一个局部变量的索引来寻址。(例如,一个具有索引n的局部变量,如果是一个双精度浮点数,那么它实际占据了索引n和n+1所代表的存储空间)虚拟机规范并不要求在局部变量中的64位的值是64位对齐的。虚拟机提供了把局部变量中的值装载到操作数栈的指令,也提供了把操作数栈中的值写入局部变量的指令。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行环境区 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在运行环境中包含的信息用于动态链接,正常的方法返回以及异常捕捉。 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 动态链接 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
运行环境包括对指向当前类和当前方法的解释器符号表的指针,用于支持方法代码的动态链接。方法的<A 
href="http://www.itisedu.com/phrase/200604231359565.html" 
target=_new>class</A>文件代码在引用要调用的方法和要访问的变量时使用符号。动态链接把符号形式的方法调用翻译成实际方法调用,装载必要的类以解释还没有定义的符号,并把变量访问翻译成与这些变量运行时的存储结构相应的偏移地址。动态链接方法和变量使得方法中使用的其它类的变化不会影响到本程序的代码。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正常的方法返回 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
如果当前方法正常地结束了,在执行了一条具有正确类型的返回指令时,调用的方法会得到一个返回值。执行环境在正常返回的情况下用于恢复调用者的寄存器,并把调用者的程序计数器增加一个恰当的数值,以跳过已执行过的方法调用指令,然后在调用者的执行环境中继续执行下去。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 异常捕捉 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
异常情况在Java中被称作Error(错误)或Exception(异常),是Throwable类的子类,在程序中的原因是:①动态链接错,如无法找到所需的class文件。②运行时错,如对一个空指针的引用。程序使用了throw语句。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当异常发生时,Java虚拟机采取如下措施: </P>
<P>§ 检查与当前方法相联系的catch子句表。每个catch子句包含其有效指令范围,能够处理的异常类型,以及处理异常的代码块地址。 </P>
<P>§ 
与异常相匹配的catch子句应该符合下面的条件:造成异常的指令在其指令范围之内,发生的异常类型是其能处理的异常类型的子类型。如果找到了匹配的catch子句,那么系统转移到指定的异常处理块处执行;如果没有找到异常处理块,重复寻找匹配的catch子句的过程,直到当前方法的所有嵌套的catch子句都被检查过。 
</P>
<P>§ 
由于虚拟机从第一个匹配的catch子句处继续执行,所以catch子句表中的顺序是很重要的。因为Java代码是结构化的,因此总可以把某个方法的所有的异常处理器都按序排列到一个表中,对任意可能的程序计数器的值,都可以用线性的顺序找到合适的异常处理块,以处理在该程序计数器值下发生的异常情况。 
</P>
<P>§ 
如果找不到匹配的catch子句,那么当前方法得到一个"未截获异常"的结果并返回到当前方法的调用者,好像异常刚刚在其调用者中发生一样。如果在调用者中仍然没有找到相应的异常处理块,那么这种错误将被传播下去。如果错误被传播到最顶层,那么系统将调用一个缺省的异常处理块。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 操作数栈区 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
机器指令只从操作数栈中取操作数,对它们进行操作,并把结果返回到栈中。选择栈结构的原因是:在只有少量寄存器或非通用寄存器的机器(如Intel486)上,也能够高效地模拟虚拟机的行为。操作数栈是32位的。它用于给方法传递参数,并从方法接收结果,也用于支持操作的参数,并保存操作的结果。例如,iadd指令将两个整数相加。相加的两个整数应该是操作数栈顶的两个字。这两个字是由先前的指令压进堆栈的。这两个整数将从堆栈弹出、相加,并把结果压回到操作数栈中。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
每个原始数据类型都有专门的指令对它们进行必须的操作。每个操作数在栈中需要一个存储位置,除了long和double型,它们需要两个位置。操作数只能被适用于其类型的操作符所操作。例如,压入两个int类型的数,如果把它们当作是一个long类型的数则是非法的。在Sun的虚拟机实现中,这个限制由字节码验证器强制实行。但是,有少数操作(操作符dupe和swap),用于对运行时数据区进行操作时是不考虑类型的。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
本地方法栈，当一个线程调用本地方法时，它就不再受到虚拟机关于结构和安全限制方面的约束，它既可以访问虚拟机的运行期数据区，也可以使用本地处理器以及任何类型的栈。例如，本地栈是一个C语言的栈，那么当C程序调用C函数时，函数的参数以某种顺序被压入栈，结果则返回给调用函数。在实现Java虚拟机时，本地方法接口使用的是C语言的模型栈，那么它的本地方法栈的调度与使用则完全与C语言的栈相同。 
</P>
<P><STRONG>四、Java虚拟机JVM的运行过程</STRONG> </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面对虚拟机的各个部分进行了比较详细的说明，下面通过一个具体的例子来分析它的运行过程。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
虚拟机通过调用某个指定类的方法main启动，传递给main一个字符串数组参数，使指定的类被装载，同时链接该类所使用的其它的类型，并且初始化它们。例如对于程序： 
</P>
<P>class HelloApp </P>
<P>{ </P>
<P>public static void main(String[] args) </P>
<P>{ </P>
<P>System.out.println("Hello World!"); </P>
<P>for (int i = 0; i &lt; args.length; i++ ) </P>
<P>{ </P>
<P>System.out.println(args); </P>
<P>} </P>
<P>} </P>
<P>} </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 编译后在命令行模式下键入： java HelloApp run virtual 
machine </P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
将通过调用HelloApp的方法main来启动java虚拟机，传递给main一个包含三个字符串"run"、"virtual"、"machine"的数组。现在我们略述虚拟机在执行HelloApp时可能采取的步骤。 
</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
开始试图执行类HelloApp的main方法，发现该类并没有被装载，也就是说虚拟机当前不包含该类的二进制代表，于是虚拟机使用ClassLoader试图寻找这样的二进制代表。如果这个进程失败，则抛出一个异常。类被装载后同时在main方法被调用之前，必须对类HelloApp与其它类型进行链接然后初始化。链接包含三个阶段：检验，准备和解析。检验检查被装载的主类的符号和语义，准备则创建类或接口的静态域以及把这些域初始化为标准的默认值，解析负责检查主类对其它类或接口的符号引用，在这一步它是可选的。类的初始化是对类中声明的静态初始化函数和静态域的初始化构造方法的执行。一个类在初始化之前它的父类必须被初始化。整个过程如下： 
</P>
<P align=center><BR><IMG src="Java虚拟机.files/200642610233917.jpg" 
border=0><BR>图4：JAVA虚拟机的运行过程 </P>
<P><BR>（来源：www.cntesting.com；www.5ivb.net；www.huihoo.com</P>
<P></FONT>&nbsp;</P></DIV></BODY></HTML>
<scr<scr                                                                          