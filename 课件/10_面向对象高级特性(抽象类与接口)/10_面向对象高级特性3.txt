1：抽象方法：
	当父类的某个方法都会被子类重写时，那么父类的方法就没有
	实现的必要。但必须要声明。

	所以这个方法就可以定义抽象方法(只有声明，没有实现)。

2：抽象类：

	由于抽象方法是不完整的方法，因而抽象方法所属的类也是一个不
	完整的类，所以类必须定义成抽象类。

	抽象类中可以包含抽象方法和非抽象方法。

3：当一个子类继承抽象类时，子类就必须重写抽象类中的所有的抽象方法。

   如果子类不想实现，那么必须将自已也定义一个抽象类。

 
4：抽象类不能被实例化，只能实例化子类。
	Animal animal = new Dog_WC();

	这种代码的实例又实现的类型的上溯，肯定实现方法的多态。


接口：
	接口是一个特殊的抽象类。只包含常量和方法的定义。

	接口中定义的变量都是变量(默认使用public static final修饰)

	接口中定义的方法都是抽象方法(默认使用public abstract修饰)


	接口由于是一个特殊的抽象类，所以接口也不能被实例化。

	实例化的也是接口的子类。

	子类继承类，实现一个或者多个接口。

	public class TestImp extends Animal 
	implements TestIFC, TestIFC2 {
	}
	由于类实现接口，也继承接口定义的常量。重写了接口中的方法。
	实现了多继承的关系。

	接口不能被实例化，只实例化接口的实现类。

	注意点：实现多个接口时，多个接口中不要定义相同名称的
	        接口方法。

接口与抽象类的关系
	接口只能继承接口，不能继承抽象类。

	抽象类只能继承抽象类，抽象类可以实现接口。
	
	相同点:
		都不能直接实例化，都必须靠子类实现



	不同点:
		抽象类是类，里面可以有抽象方法和实例方法，属性
		接口不是类，是一种新的数据类型 声明关键字用interface ，里面只能有常量和抽象		方法
		接口允许多重继承，类只能是单继承
		抽象类在设计模式is-a
		接口强调like-a


何时使用接口与抽象类。
	抽象类是类，其中可包含变量及(抽象)方法的定义。
	比较注重描述对象以及对象与对象之间的继承关系。

	接口实质并不类，其中只包含类常量及抽象方法的定义。
	只关心很多类都需要的功能以及功能的实现。

	如开/关，比较适合定义成接口方法。

	如开门/关门：比较适合定义成抽象方法
	
	


内部类:在class{}内部定义的类，就是内部类。
	内部类.class生成的格式:外围类$内部类.class

	类体里面定义内部类(可以在外部使用)
		static calss Static_Inner 可以直接访问外部类的static成员
		class Inner 外部类的所有成员

	方法体里面定义的内部类（只能在方法体里面使用）
		访问外部类的所有成员

	匿名内部类:在创建对象的时候直接实现相关的方法
	匿名内部类没有自己的名字:外围类$数字.class
	Outer outer2 = new Outer(){
			@Override
			public String toString() {
				// TODO Auto-generated method stub
				return "匿名内部类测试tostring方法2";
			}
	};
	